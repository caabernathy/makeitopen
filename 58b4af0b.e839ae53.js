(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{101:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return u}));var n=a(0),i=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function c(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=i.a.createContext({}),p=function(e){var t=i.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):c(c({},t),e)),a},b=function(e){var t=p(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},h=i.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,r=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),b=p(a),h=n,u=b["".concat(r,".").concat(h)]||b[h]||d[h]||o;return a?i.a.createElement(u,c(c({ref:t},l),{},{components:a})):i.a.createElement(u,c({ref:t},l))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,r=new Array(o);r[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:n,r[1]=c;for(var l=2;l<o;l++)r[l]=a[l];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,a)}h.displayName="MDXCreateElement"},107:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/iOS_vs_Android_Segmented_Controls@3x-7178eb5696bc1a373124b7a5a63866b2.png"},115:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/redux_flowchart-5d27b7fc7e70491f3dad2e90745bf697.png"},69:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return r})),a.d(t,"metadata",(function(){return c})),a.d(t,"rightToc",(function(){return s})),a.d(t,"default",(function(){return p}));var n=a(2),i=a(6),o=(a(0),a(101)),r={id:"1-3-data",title:"Integrating Data with React Native",sidebar_label:"Part 3: Integrating Data with React Native",original_id:"1-3-data"},c={unversionedId:"1-3-data",id:"version-2016.1.1.0/1-3-data",isDocsHomePage:!1,title:"Integrating Data with React Native",description:"This is a series of tutorials designed to introduce React Native and its Open Source ecosystem in plain English, written alongside the building of the F8 2016 app for Android and iOS.",source:"@site/versioned_docs/version-2016.1.1.0/1-3-data.md",slug:"/1-3-data",permalink:"/makeitopen/docs/2016.1.1.0/1-3-data",editUrl:"https://github.com/facebook/makeitopen/edit/master/docs/versioned_docs/version-2016.1.1.0/1-3-data.md",version:"2016.1.1.0",lastUpdatedBy:"Christine Abernathy",lastUpdatedAt:1604512976,sidebar_label:"Part 3: Integrating Data with React Native",sidebar:"version-2016.1.1.0/docs",previous:{title:"Designing an App for Multiple Platforms",permalink:"/makeitopen/docs/2016.1.1.0/1-2-design"},next:{title:"Testing a React Native App",permalink:"/makeitopen/docs/2016.1.1.0/1-4-testing"}},s=[{value:"First, how do React apps interact with data?",id:"first-how-do-react-apps-interact-with-data",children:[]},{value:"Storing State",id:"storing-state",children:[]},{value:"Flux to Redux",id:"flux-to-redux",children:[]},{value:"Putting This Together",id:"putting-this-together",children:[]},{value:"Reducers",id:"reducers",children:[]},{value:"Actions",id:"actions",children:[]},{value:"Binding to Components",id:"binding-to-components",children:[]},{value:"What about Parse Server?",id:"what-about-parse-server",children:[]}],l={rightToc:s};function p(e){var t=e.components,r=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("em",{parentName:"p"},"This is a series of tutorials designed to introduce React Native and its Open Source ecosystem in plain English, written alongside the building of the F8 2016 app for ",Object(o.b)("a",Object(n.a)({parentName:"em"},{href:"https://play.google.com/store/apps/details?id=com.facebook.f8"}),"Android")," and ",Object(o.b)("a",Object(n.a)({parentName:"em"},{href:"https://itunes.apple.com/us/app/f8/id853467066"}),"iOS"),".")),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://facebook.github.io/react/"}),"React"),", and by extension ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://facebook.github.io/react-native/"}),"React Native"),", allows you to build apps without worrying too much about where your data is coming from, so that you can get on with the business of creating the app's UI and its logic."),Object(o.b)("p",null,"In ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"tutorials/building-the-f8-app/planning/"}),"the first part"),", we mentioned how we were adopting Parse Server to actually hold the data, and we would use Redux to handle it within the app. In this part, we'll explain how Redux works within React Native apps, and the simple process of connecting Parse Server."),Object(o.b)("p",null,"Before we discuss Redux, let's take a journey to show how React's integration with data evolved to create Redux itself."),Object(o.b)("h3",{id:"first-how-do-react-apps-interact-with-data"},"First, how do React apps interact with data?"),Object(o.b)("p",null,"React is frequently mentioned as being the 'View' in the Model-View-Controller (MVC) app architecture, but it is more subtle than that - React essentially rethinks the overall MVC pattern into something else."),Object(o.b)("p",null,"Let's first examine the idea of MVC architecture:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The model is the data."),Object(o.b)("li",{parentName:"ul"},"The view is how the data is presented in an app."),Object(o.b)("li",{parentName:"ul"},"The controller provides the logic for handling data within the app.")),Object(o.b)("p",null,"React lets you create multiple components which are combined to form a view, but each component can also handle the logic that a controller might have provided. For example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"class Example extends React.Component {\n    render() {\n        // Code that renders the view of the existing data, and\n        // potentially a form to trigger changes to that data through\n        // the handleSubmit function\n    }\n\n    handleSubmit(e) {\n        // Code that modifies the data, like a controller's logic\n    }\n};\n")),Object(o.b)("p",null,"Each component in a React app is also aware of two different types of data, each having different roles:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"props")," is data which is passed into a component when it is created, used as the 'options' which you want for any given component. If you had a button component, an example ",Object(o.b)("inlineCode",{parentName:"li"},"prop")," would be the text of the button. A component can't change its ",Object(o.b)("inlineCode",{parentName:"li"},"props")," (ie. they are immutable)."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"state")," is data which can be changed over time by any component. If the button example above was a login/logout button, then the ",Object(o.b)("inlineCode",{parentName:"li"},"state")," would store the current login status of the user, and the button would be able to access this, and modify it if they clicked on the button to change their status.")),Object(o.b)("p",null,"In order for React apps to reduce repetition, ",Object(o.b)("inlineCode",{parentName:"p"},"state")," is intended to be owned by the highest parent component in the app's component hierarchy - something we'll refer to as ",Object(o.b)("strong",{parentName:"p"},"container components"),Object(o.b)("a",{name:"containercomponents"})," elsewhere in this tutorial. In other words, you wouldn't actually put the state in the example button component mentioned above, you'd have it in the parent view which contains the button, and then use ",Object(o.b)("inlineCode",{parentName:"p"},"props")," to pass relevant parts of the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," down to child components. Because of this, data only flows one-way downwards through any given app, which keeps everything fast and modular."),Object(o.b)("p",null,"If you would like, you can read more about the reasons and thinking behind these decisions in the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://facebook.github.io/react/docs/thinking-in-react.html"}),"Thinking in React")," guide from the React site."),Object(o.b)("h3",{id:"storing-state"},"Storing State"),Object(o.b)("p",null,"To further explain techniques for data use in React apps, Facebook introduced the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://facebook.github.io/flux/docs/overview.html"}),"Flux architecture")," which was initially a pattern to implement in your apps, rather than an actual framework to use. We aren't using the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/facebook/flux"}),"Flux library")," in our app, but the framework we are using, Redux, ",Object(o.b)("em",{parentName:"p"},"is")," derived from the Flux architecture, so let's dig into it."),Object(o.b)("p",null,"It expands on React's data relationship by introducing the concept of Stores, containers for the app's ",Object(o.b)("inlineCode",{parentName:"p"},"state")," objects, and a new workflow for modifying the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," over time:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Each ",Object(o.b)("strong",{parentName:"li"},"Store")," in a Flux app has a callback function which is registered with a Dispatcher."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Views")," (basically React components) can trigger ",Object(o.b)("strong",{parentName:"li"},"Actions")," - basically an object which includes a bunch of data about the thing that just happened (for example, maybe it might include new data that was input into a form in the app) as well as an ",Object(o.b)("strong",{parentName:"li"},"action type")," - essentially a constant that describes the type of Action being performed."),Object(o.b)("li",{parentName:"ul"},"The Action is sent to the ",Object(o.b)("strong",{parentName:"li"},"Dispatcher"),"."),Object(o.b)("li",{parentName:"ul"},"The Dispatcher propagates this Action to all of the various registered Store callbacks."),Object(o.b)("li",{parentName:"ul"},"If the Store can tell that it was affected by an Action (because the action type is related to its data), it will update itself, and therefore the contained ",Object(o.b)("inlineCode",{parentName:"li"},"state"),". Once updated, it'll emit a change event."),Object(o.b)("li",{parentName:"ul"},"Special Views called ",Object(o.b)("strong",{parentName:"li"},"Controller Views")," (a fancy term for the ",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"/tutorials/building-the-f8-app/data/#containercomponents"}),"container components")," we mentioned above) will be listening for these change events, and when they get one, they know they should fetch the new Store data.")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Once fetched they call ",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://facebook.github.io/react/docs/component-api.html#setstate"}),Object(o.b)("inlineCode",{parentName:"a"},"setState()"))," with the new data, causing the components inside the View to re-render.")),Object(o.b)("p",null,"You can see how Flux helps to enforce the one-way flow of data within React apps, and it makes the data part of React much more elegant and structured."),Object(o.b)("p",null,"We aren't using Flux, so we won't get into more detail in this piece, but if you want to learn more about it, there are some ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://facebook.github.io/flux/docs/todo-list.html"}),"tutorials")," on the Flux site to read."),Object(o.b)("p",null,"So how is Flux related to Redux, the actual framework we are using in our app?"),Object(o.b)("h3",{id:"flux-to-redux"},"Flux to Redux"),Object(o.b)("p",null,"Redux is a framework implementation of the Flux architecture, but it also strips it down, and there are ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/reactjs/react-redux"}),"official bindings provided by the react-redux package")," which make integrating it with React apps much easier."),Object(o.b)("p",null,"There is no dispatcher in Redux, and there is only one Store for the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," of the entire app."),Object(o.b)("p",null,"How does the data flow work in Redux? We'll go over this in detail below, but here are the basics:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"React components can cause Actions to be triggered, for example by a button click."),Object(o.b)("li",{parentName:"ul"},"Actions are an object (containing a ",Object(o.b)("inlineCode",{parentName:"li"},"type")," label and other data related to the Action) sent to the Store via the ",Object(o.b)("inlineCode",{parentName:"li"},"dispatch")," function."),Object(o.b)("li",{parentName:"ul"},"The Store then takes the Action payload and sends it to the Reducers along with the current ",Object(o.b)("inlineCode",{parentName:"li"},"state")," tree (",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"https://egghead.io/lessons/javascript-redux-the-single-immutable-state-tree"}),"a ",Object(o.b)("inlineCode",{parentName:"a"},"state")," tree")," is the single object that contains all ",Object(o.b)("inlineCode",{parentName:"li"},"state")," data in a particular structure)"),Object(o.b)("li",{parentName:"ul"},"A ",Object(o.b)("strong",{parentName:"li"},"Reducer")," is a ",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"http://redux.js.org/docs/basics/Reducers.html#handling-actions"}),"pure function")," that takes the previous ",Object(o.b)("inlineCode",{parentName:"li"},"state")," and an Action, then returns a new ",Object(o.b)("inlineCode",{parentName:"li"},"state")," based on any changes that the Action might have indicated. A Redux app can have one Reducer, but most apps will end up with several that each handle a different part of the ",Object(o.b)("inlineCode",{parentName:"li"},"state")," (we'll discuss this more ",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"/tutorials/building-the-f8-app/data/#reducers"}),"below"),")."),Object(o.b)("li",{parentName:"ul"},"The Store receives this new ",Object(o.b)("inlineCode",{parentName:"li"},"state")," and replaces the current one with it. It's worth noting here that when we say the ",Object(o.b)("inlineCode",{parentName:"li"},"state")," is ",Object(o.b)("em",{parentName:"li"},"updated"),", it is technically ",Object(o.b)("em",{parentName:"li"},"replaced"),"."),Object(o.b)("li",{parentName:"ul"},"When the ",Object(o.b)("inlineCode",{parentName:"li"},"state")," changes, the Store triggers a ",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"http://redux.js.org/docs/api/Store.html#subscribe"}),"change event"),"."),Object(o.b)("li",{parentName:"ul"},"Any React components that have ",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"http://redux.js.org/docs/api/Store.html#subscribe"}),"subscribed to the change event")," make a call to ",Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"http://redux.js.org/docs/api/Store.html#getState"}),"retrieve the new ",Object(o.b)("inlineCode",{parentName:"a"},"state")," from the Store"),"."),Object(o.b)("li",{parentName:"ul"},"The components are updated with the new ",Object(o.b)("inlineCode",{parentName:"li"},"state"),".")),Object(o.b)("p",null,"This flow can be summarized in the below diagram for simplicity:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"Redux data flow as described above",src:a(115).default})),Object(o.b)("p",null,"You can see how data follows a clear one-way path, there are no overlapping, opposite direction flows. What this also shows is how clearly separated each part of an app can be - the Store is only concerned with holding the ",Object(o.b)("inlineCode",{parentName:"p"},"state"),"; the components in the Views are only concerned with displaying data and triggering Actions; Actions are only concerned with indicating that something in the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," has changed and including data about what it was; Reducers are only concerned with combining an old ",Object(o.b)("inlineCode",{parentName:"p"},"state")," and mutating Actions into a new ",Object(o.b)("inlineCode",{parentName:"p"},"state"),". Everything is modular, elegant, and has a clear purpose when it comes to reading the code and understanding it."),Object(o.b)("p",null,"There are some other benefits compared to Flux:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Actions are the only way to trigger a ",Object(o.b)("inlineCode",{parentName:"li"},"state")," change, this centralizes this process away from the UI components, and because they are properly ordered by the Reducer, it prevents race conditions."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"state")," becomes essentially immutable, and a series of ",Object(o.b)("inlineCode",{parentName:"li"},"state"),"s, each representing an individual change, are created. This gives you a clear and easily traceable ",Object(o.b)("inlineCode",{parentName:"li"},"state")," history within your app.")),Object(o.b)("h3",{id:"putting-this-together"},"Putting This Together"),Object(o.b)("p",null,"So now that we've talked about the data flow in the abstract, let's look at how our React Native app puts it all to use, and anything we learned along the way."),Object(o.b)("h4",{id:"store"},"Store"),Object(o.b)("p",null,"The ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://redux.js.org/docs/basics/Store.html"}),"Redux docs")," explain very well how to create a simple Store, so we're going to assume you've read the basics there and skip ahead a little bit, including a few extras with our Store."),Object(o.b)("h5",{id:"offline-syncing-of-store"},"Offline Syncing of Store"),Object(o.b)("p",null,"We've talked before about needing local offline storage of the data, so that the app can operate in low-signal or no-signal conditions (vital at a tech conference!). Luckily, because we're using Redux, there's a very simple module we can use with our app called ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.npmjs.com/package/redux-persist"}),"Redux Persist"),"."),Object(o.b)("p",null,"We're also using something called ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://redux.js.org/docs/advanced/Middleware.html"}),Object(o.b)("strong",{parentName:"a"},"Middleware"))," with our Store - we'll talk more about some of the things we use this for in the testing section, but basically, middleware allows you to fit extra logic in between the point of an Action being dispatched, and when it reaches the Reducer (this is useful for things like logging, crash reporting, asynchronous APIs, etc.)."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* js/store/configureStore.js */\nvar createF8Store = applyMiddleware(...)(createStore);\n\nfunction configureStore(onComplete: ?() => void) {\n  const store = autoRehydrate()(createF8Store)(reducers);\n  persistStore(store, {storage: AsyncStorage}, onComplete);\n  ...\n  return store;\n}\n")),Object(o.b)("p",null,"The nested function syntax might be a little confusing here (some of these functions ",Object(o.b)("em",{parentName:"p"},"return")," functions that take ",Object(o.b)("em",{parentName:"p"},"another")," function as an argument), so here it is expanded a bit:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* js/store/configureStore.js */\n\nvar middlewareWrapper = applyMiddleware(...); // 1\nvar createF8Store = middlewareWrapper(createStore(reducers)); // 2\n\nfunction configureStore(onComplete: ?() => void) { // 3\n  const rehydrator = autoRehydrate(); // 4\n  const store = rehydrator(createF8Store); // 5\n  persistStore(store, {storage: AsyncStorage}, onComplete); // 6\n  ...\n  return store;\n}\n")),Object(o.b)("p",null,"Here's what's going on:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"We activate the middleware using Redux's ",Object(o.b)("inlineCode",{parentName:"p"},"applyMiddleware()")," function (if you want to know more, read the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://redux.js.org/docs/api/applyMiddleware.html"}),"Redux ",Object(o.b)("inlineCode",{parentName:"a"},"applyMiddleware")," docs"),") which itself ",Object(o.b)("em",{parentName:"p"},"returns a function")," that will 'enhance' the Store object.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"So we wrap Redux's ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://redux.js.org/docs/api/createStore.html"}),Object(o.b)("inlineCode",{parentName:"a"},"createStore()"))," function (with all the Reducers in our app as an argument) in that enhancer function. ",Object(o.b)("inlineCode",{parentName:"p"},"createStore()")," returns a Store object for our app, ",Object(o.b)("inlineCode",{parentName:"p"},"middlewareWrapper()")," 'enhances' it with the middleware, and the resulting enhanced Store object is saved in ",Object(o.b)("inlineCode",{parentName:"p"},"createF8Store"),".")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Then we configure our Store object a little bit.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/rt2zz/redux-persist#autorehydrate"}),"Persist's ",Object(o.b)("inlineCode",{parentName:"a"},"autoRehydrate()"))," is another Store enhancer function (as with ",Object(o.b)("inlineCode",{parentName:"p"},"applyMiddleware()")," that returns a function).")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"We pass it our existing Store object. This ",Object(o.b)("inlineCode",{parentName:"p"},"autoRehydrate()")," takes a Store object previously saved to local storage and automatically updates the current Store with it's ",Object(o.b)("inlineCode",{parentName:"p"},"state"),".")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/rt2zz/redux-persist#persiststorestore-config-callback"}),"Persist package's ",Object(o.b)("inlineCode",{parentName:"a"},"persistStore()"))," (which we configure to use ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://facebook.github.io/react-native/docs/asyncstorage.html"}),"React Native's built-in AsyncStorage system"),") is the function that actually takes care of saving the app's Store to local storage. This simple bit of ",Object(o.b)("inlineCode",{parentName:"p"},"autoRehydrate()")," and ",Object(o.b)("inlineCode",{parentName:"p"},"persistStore()")," code is all we need to enable offline sync in our app."))),Object(o.b)("p",null,"Now, whenever the app loses Internet connectivity, the most recent copy of the Store (including any Parse data we had to grab via the API) will still be there waiting in local storage, and from the user's perspective, the app will just work."),Object(o.b)("p",null,"For more information, you can read about the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.npmjs.com/package/redux-persist#basic-usage"}),"technical details of how the Redux Persist package works"),", but essentially we're done creating our Store."),Object(o.b)("h3",{id:"reducers"},"Reducers"),Object(o.b)("p",null,"In the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"#flux-to-redux"}),"previous explanation of Redux"),", we mentioned that it introduced a Reducer object. However in each app there can be multiple Reducers, which are concerned with different parts of the ",Object(o.b)("inlineCode",{parentName:"p"},"state"),". As a basic example, in a commenting app you might have a reducer related to login status, and others related to the actual comment data."),Object(o.b)("p",null,"In our F8 app, we store our reducers in ",Object(o.b)("inlineCode",{parentName:"p"},"js/reducers/"),". Here's a condensed look at ",Object(o.b)("inlineCode",{parentName:"p"},"user.js"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* js/reducers/user.js */\n...\nimport type {Action} from '../actions/types';\n...\n\nconst initialState = { // 1\n  isLoggedIn: false,\n  hasSkippedLogin: false,\n  sharedSchedule: null,\n  id: null,\n  name: null,\n};\n// 2\nfunction user(state: State = initialState, action: Action): State {\n  if (action.type === 'LOGGED_IN') {\n    let {id, name, sharedSchedule} = action.data; // de-structuring action data\n    return {\n      isLoggedIn: true,\n      hasSkippedLogin: false,\n      sharedSchedule,\n      id,\n      name,\n    };\n  }\n  if (action.type === 'SKIPPED_LOGIN') {\n    return {\n      isLoggedIn: false,\n      hasSkippedLogin: true,\n      sharedSchedule: null,\n      id: null,\n      name: null,\n    };\n  }\n  if (action.type === 'LOGGED_OUT') {\n    return initialState;\n  }\n  if (action.type === 'SET_SHARING') {\n    return {\n      ...state,\n      sharedSchedule: action.enabled,\n    };\n  }\n  return state;\n}\n\nmodule.exports = user;\n")),Object(o.b)("p",null,"As you might be able to tell, this reducer is involved with login/logout operations, as well as user specific option changes. Let's go through it piece by piece."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note: we're using ES2015's ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"}),"destructuring assignment")," to assign each of the left side variables to each of the pieces of the data in the list in ",Object(o.b)("inlineCode",{parentName:"p"},"action.data"),".")),Object(o.b)("h5",{id:"1-initial-state"},"1. Initial State"),Object(o.b)("p",null,"At the beginning we define the initial state, which conforms to a ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://flowtype.org/docs/type-aliases.html"}),"Flow Type Alias")," (we'll explain more about these in ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/makeitopen/docs/2016.1.1.0/1-4-testing"}),"Testing a React Native app"),"). This ",Object(o.b)("inlineCode",{parentName:"p"},"initialState")," defines the values - for the part of the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," tree that this Reducer handles - that the app will have on first load, or before any previously synced Store is 'rehydrated' as above."),Object(o.b)("h5",{id:"2-the-reducer-function"},"2. The Reducer Function"),Object(o.b)("p",null,"Then, we write the meat of the Reducer, and it is actually relatively simple. ",Object(o.b)("inlineCode",{parentName:"p"},"state")," and an Action (which we will ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"#actions"}),"discuss below"),") are taken as arguments, with the ",Object(o.b)("inlineCode",{parentName:"p"},"initialState")," as a default for ",Object(o.b)("inlineCode",{parentName:"p"},"state")," (and we're using ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://flowtype.org/docs/type-annotations.html#_"}),"Flow type annotations")," for the arguments here, again something we'll cover in ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/makeitopen/docs/2016.1.1.0/1-4-testing"}),"Testing a React Native app"),"). Then, we use the received Action, specifically whatever 'type' label it had, and return a new, changed ",Object(o.b)("inlineCode",{parentName:"p"},"state"),"."),Object(o.b)("p",null,"For example, if the ",Object(o.b)("inlineCode",{parentName:"p"},"LOGGED_OUT")," Action was dispatched (because the user clicked a log-out button), we reset this part of the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," tree to ",Object(o.b)("inlineCode",{parentName:"p"},"initialState"),". If the ",Object(o.b)("inlineCode",{parentName:"p"},"LOGGED_IN")," Action type happens, you can see that the app will use the rest of the data payload, and return a new ",Object(o.b)("inlineCode",{parentName:"p"},"state")," that reflects both standard changes like ",Object(o.b)("inlineCode",{parentName:"p"},"isLoggedIn"),", but changes that come from user-inputted data, such as ",Object(o.b)("inlineCode",{parentName:"p"},"name"),"."),Object(o.b)("p",null,"There's one more we'll look at, and that's the ",Object(o.b)("inlineCode",{parentName:"p"},"SET_SHARING")," Action type. It is interesting because of the ",Object(o.b)("inlineCode",{parentName:"p"},"...state")," notation being used. This is a more compact and readable alternative to ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"}),Object(o.b)("inlineCode",{parentName:"a"},"Object.assign()"))," that is part of the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://facebook.github.io/react-native/docs/javascript-environment.html#javascript-syntax-transformers"}),"Javascript syntax transformers included in React")," (called the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html"}),"Object Spread Operator"),"), and all it really does in this case is create an object that copies the existing ",Object(o.b)("inlineCode",{parentName:"p"},"state"),", and updates the ",Object(o.b)("inlineCode",{parentName:"p"},"sharedSchedule")," value."),Object(o.b)("p",null,"You can see how simple and readable this Reducer structure is - define an ",Object(o.b)("inlineCode",{parentName:"p"},"initialState"),", build a function that takes a ",Object(o.b)("inlineCode",{parentName:"p"},"state")," and an Action, and returns a new ",Object(o.b)("inlineCode",{parentName:"p"},"state"),". That's it."),Object(o.b)("p",null,"We don't do anything else in this function because of the one big rule with reducers, and we'll quote the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://redux.js.org/docs/basics/Reducers.html#handling-actions"}),"Redux docs")," verbatim:"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},'"Remember that the reducer must be pure. Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation."')),Object(o.b)("p",null,"One other thing to take notice of: looking at ",Object(o.b)("inlineCode",{parentName:"p"},"js/reducers/notifications.js")," there's another reference to the ",Object(o.b)("inlineCode",{parentName:"p"},"LOGGED_OUT")," action type; we mentioned this before, but it bears repeating - each reducer is always called after an Action is dispatched, so multiple reducers may be updating different parts of the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," tree based on the same Action."),Object(o.b)("h3",{id:"actions"},"Actions"),Object(o.b)("p",null,"Let's have a closer look at a login-related Action, and see where it sits in the code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/actions/login.js */\nfunction skipLogin(): Action {\n  return {\n    type: 'SKIPPED_LOGIN',\n  };\n}\n")),Object(o.b)("p",null,"This is a really simple ",Object(o.b)("strong",{parentName:"p"},"Action creator")," (the object returned by this creator function is the actual Action), but it lets you see the basic structure - each Action can simply be an object containing a custom ",Object(o.b)("inlineCode",{parentName:"p"},"type")," label. The reducers can then use this ",Object(o.b)("inlineCode",{parentName:"p"},"type")," to perform the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," updates."),Object(o.b)("p",null,"We can also include some data payload along with the ",Object(o.b)("inlineCode",{parentName:"p"},"type"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/actions/filter.js */\nfunction applyTopicsFilter(topics): Action {\n  return {\n    type: 'APPLY_TOPICS_FILTER',\n    topics: topics,\n  };\n}\n")),Object(o.b)("p",null,"The Action creator here receives an argument and inserts it into the Action object."),Object(o.b)("p",null,"We then have some Action creators that perform additional logic as well as returning the Action object. In this example, we're also using a custom Action derivative called a ThunkAction (",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://redux.js.org/docs/recipes/ReducingBoilerplate.html"}),"Redux recommends you create something like this to reduce boilerplate"),") - this special type of Action creator returns a function not an Action. In this case the ",Object(o.b)("inlineCode",{parentName:"p"},"logOut()")," Action creator returns a function which performs some logout related logic, and then dispatches an Action."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/actions/login.js */\nfunction logOut(): ThunkAction {\n  return (dispatch) => {\n    Parse.User.logOut();\n    FacebookSDK.logout();\n    ...\n\n    return dispatch({\n      type: 'LOGGED_OUT',\n    });\n  };\n}\n")),Object(o.b)("p",null,"(Note we're also using the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions"}),"Arrow function syntax")," in this example)"),Object(o.b)("h5",{id:"async-actions"},"Async Actions"),Object(o.b)("p",null,"If, for example, you're interacting with any APIs, you'll need some asynchronous Action creators. Redux on its own has ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://redux.js.org/docs/advanced/AsyncActions.html"}),"a fairly complex approach to async"),", but because we're using React Native, we have access to ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://facebook.github.io/react-native/docs/javascript-environment.html#javascript-syntax-transformers"}),"ES7 ",Object(o.b)("inlineCode",{parentName:"a"},"await")," functionality")," which simplifies the process:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/actions/config.js */\nasync function loadConfig(): Promise<Action> {\n  const config = await Parse.Config.get();\n  return {\n    type: 'LOADED_CONFIG',\n    config,\n  };\n}\n")),Object(o.b)("p",null,"Here, we're making an API call to Parse to grab some app configuration data. Any API call to a web resource like this will take a certain amount of time. Instead of the Action being immediately dispatched, the action creator first waits for the result of API call (without blocking the JavaScript thread), and then once that data is available, then the Action object (with the API data in the payload) is returned."),Object(o.b)("p",null,"One of the benefits of asynchronous calls like this is that while we await the result of the ",Object(o.b)("inlineCode",{parentName:"p"},"Parse.Config")," call, other async operations can be doing work, so we can bucket a lot of operations together and automatically improved their efficiency."),Object(o.b)("h3",{id:"binding-to-components"},"Binding to Components"),Object(o.b)("p",null,"Now, we connect our Redux logic to React inside of our app's setup function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/setup.js */\nfunction setup(): React.Component {\n  // ... other setup logic\n\n  class Root extends React.Component {\n    constructor() {\n      super();\n      this.state = {\n        store: configureStore(),\n      };\n    }\n    render() {\n      return (\n        <Provider store={this.state.store}>\n          <F8App />\n        </Provider>\n      );\n    }\n  }\n\n  return Root;\n}\n")),Object(o.b)("p",null,"We're using the official ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/reactjs/react-redux"}),"React and Redux bindings"),", so we can use the built in ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://redux.js.org/docs/basics/UsageWithReact.html#passing-the-store"}),Object(o.b)("inlineCode",{parentName:"a"},"<Provider>")," component"),". This Provider lets us connect the Store that we've created to any components that we want:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/F8App.js */\nvar F8App = React.createClass({\n  ...\n})\n\nfunction select(state) {\n  return {\n    notifications: state.notifications,\n    isLoggedIn: state.user.isLoggedIn || state.user.hasSkippedLogin,\n  };\n}\n\nmodule.exports = connect(select)(F8App);\n")),Object(o.b)("p",null,"Above we are showing a section of code from the ",Object(o.b)("inlineCode",{parentName:"p"},"<F8App>")," component - the parent component of our entire app."),Object(o.b)("p",null,"The function above is used to take the Redux Store, then take some data from it, and insert it into the ",Object(o.b)("inlineCode",{parentName:"p"},"props")," for our ",Object(o.b)("inlineCode",{parentName:"p"},"<F8App>")," component. In this case, we want data about notifications and the login status of the user to be ",Object(o.b)("inlineCode",{parentName:"p"},"props")," in that component, and for them to be kept up to date with any Store changes."),Object(o.b)("p",null,"We can use the React-Redux ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options"}),Object(o.b)("inlineCode",{parentName:"a"},"connect()")," function")," to accomplish this - ",Object(o.b)("inlineCode",{parentName:"p"},"connect()")," has an argument named ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/reactjs/react-redux/blob/master/docs/api.md#arguments"}),Object(o.b)("inlineCode",{parentName:"a"},"mapStateToProps"))," which takes another function and any time there is a Store update, that function will be called."),Object(o.b)("p",null,"So when our app's Store updates, ",Object(o.b)("inlineCode",{parentName:"p"},"select()")," will be called, with the new ",Object(o.b)("inlineCode",{parentName:"p"},"state")," supplied as an argument. ",Object(o.b)("inlineCode",{parentName:"p"},"select()")," returns an object containing the data (in this case ",Object(o.b)("inlineCode",{parentName:"p"},"notifications")," and ",Object(o.b)("inlineCode",{parentName:"p"},"isLoggedIn"),") we want from this new ",Object(o.b)("inlineCode",{parentName:"p"},"state"),", then the ",Object(o.b)("inlineCode",{parentName:"p"},"connect()")," call merges this data into the ",Object(o.b)("inlineCode",{parentName:"p"},"props")," for the ",Object(o.b)("inlineCode",{parentName:"p"},"<F8App>")," component:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/F8App.js */\nvar F8App = React.createClass({\n  ...\n  componentDidMount: function() {\n    ...\n    if (this.props.notifications.enabled && !this.props.notifications.registered) {\n      ...\n    }\n    ...\n  },\n  ...\n})\n")),Object(o.b)("p",null,"We now have an ",Object(o.b)("inlineCode",{parentName:"p"},"<F8App>")," component that will be updated with any new ",Object(o.b)("inlineCode",{parentName:"p"},"state")," data that it has subscribed to through the ",Object(o.b)("inlineCode",{parentName:"p"},"select()")," function, which it can access through its own props. But how to we dispatch Actions from a component?"),Object(o.b)("h5",{id:"dispatching-actions-from-components"},"Dispatching Actions from Components"),Object(o.b)("p",null,"To see how we can connect Actions to components, let's take a look at the relevant parts of ",Object(o.b)("inlineCode",{parentName:"p"},"<GeneralScheduleView>"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/tabs/schedule/GeneralScheduleView.js */\nclass GeneralScheduleView extends React.Component {\n  props: Props;\n\n  constructor(props) {\n    super(props);\n    this.renderStickyHeader = this.renderStickyHeader.bind(this);\n    ...\n    this.switchDay = this.switchDay.bind(this);\n  }\n\n  render() {\n    return (\n      <ListContainer\n        title=\"Schedule\"\n        backgroundImage={require('./img/schedule-background.png')}\n        backgroundShift={this.props.day - 1}\n        backgroundColor={'#5597B8'}\n        data={this.props.data}\n        renderStickyHeader={this.renderStickyHeader}\n        ...\n      />\n    );\n  }\n\n  ...\n\n  renderStickyHeader() {\n    return (\n      <View>\n        <F8SegmentedControl\n          values={['Day 1', 'Day 2']}\n          selectedIndex={this.props.day - 1}\n          selectionColor=\"#51CDDA\"\n          onChange={this.switchDay}\n        />\n        ...\n      </View>\n    );\n  }\n\n  ...\n\n  switchDay(page) {\n    this.props.switchDay(page + 1);\n  }\n}\n\nmodule.exports = GeneralScheduleView;\n")),Object(o.b)("p",null,"Again, this code has been heavily simplified for ease of learning, but we can now add and modify code to connect this ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/tutorials/building-the-f8-app/data/#containercomponents"}),"container component")," to the Redux store:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/tabs/schedule/GeneralScheduleView.js */\nfunction select(store) {\n  return {\n    day: store.navigation.day,\n    data: data(store),\n  };\n}\n\nfunction actions(dispatch) {\n  return {\n    switchDay: (day) => dispatch(switchDay(day)),\n  }\n}\n\nmodule.exports = connect(select, actions)(GeneralScheduleView);\n")),Object(o.b)("p",null,"There's a difference this time - we provide the React-Redux ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options"}),Object(o.b)("inlineCode",{parentName:"a"},"connect()")," function"),"'s optional argument, ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/reactjs/react-redux/blob/master/docs/api.md#arguments"}),Object(o.b)("inlineCode",{parentName:"a"},"mapDispatchToProps")),". Basically, doing this merges the action creators inside ",Object(o.b)("inlineCode",{parentName:"p"},"actions()")," into the component's props, while wrapping them in ",Object(o.b)("inlineCode",{parentName:"p"},"dispatch()")," so that they immediately dispatch an Action."),Object(o.b)("h5",{id:"how-it-works"},"How it Works"),Object(o.b)("p",null,"Let's see the actual component:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"Screenshot of segmented controls",src:a(107).default})),Object(o.b)("p",null,"Tapping on 'Day 1' here would trigger the ",Object(o.b)("inlineCode",{parentName:"p"},"onChange")," event in ",Object(o.b)("inlineCode",{parentName:"p"},"renderStickyHeader()"),", then the ",Object(o.b)("inlineCode",{parentName:"p"},"switchDay()")," function inside the component is called, and that function itself dispatches the ",Object(o.b)("inlineCode",{parentName:"p"},"this.props.switchDay()")," action creator. Inside one of our Actions files we can see this action creator:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/actions/navigation.js */\n  switchDay: (day): Action => ({\n    type: 'SWITCH_DAY',\n    day,\n  })\n")),Object(o.b)("p",null,"And inside the navigation Reducer we can see that this generates a new ",Object(o.b)("inlineCode",{parentName:"p"},"state")," tree with a modified ",Object(o.b)("inlineCode",{parentName:"p"},"day")," value:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/reducers/navigation.js */\n  if (action.type === 'SWITCH_DAY') {\n    return {...state, day: action.day};\n  }\n")),Object(o.b)("p",null,"The Reducer (and any other Reducers that might be watching for ",Object(o.b)("inlineCode",{parentName:"p"},"SWITCH_DAY")," Actions) returns the new ",Object(o.b)("inlineCode",{parentName:"p"},"state")," back to the Store, which updates itself and sends out a change event."),Object(o.b)("p",null,"And because by connecting ",Object(o.b)("inlineCode",{parentName:"p"},"<GeneralScheduleView>")," to the Redux Store we also subscribed it to changes to the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," in that Store, the component will now update with the newly changed ",Object(o.b)("inlineCode",{parentName:"p"},"day")," value, displaying 'Day 1' schedules."),Object(o.b)("h3",{id:"what-about-parse-server"},"What about Parse Server?"),Object(o.b)("p",null,"You've hopefully consumed a lot of new information by now in this tutorial, but let's quickly show how we can connect our React Native app to our Parse Server data backend, and its relevant API:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"  Parse.initialize(\n    'PARSE_APP_ID',\n  );\n  Parse.serverURL = 'http://exampleparseserver.com:1337/parse'\n")),Object(o.b)("p",null,"That's it, we're connected to the Parse API inside React Native."),Object(o.b)("p",null,"Yep, because we're using the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/ParsePlatform/ParseReact"}),"Parse + React")," SDK (specifically the ",Object(o.b)("inlineCode",{parentName:"p"},"parse/react-native")," package in it), we have incredibly simple SDK access baked right in."),Object(o.b)("h5",{id:"parse-and-actions"},"Parse and Actions"),Object(o.b)("p",null,"Of course, we want to be able to also make queries (for example, inside our Actions)....a lot of queries. There's nothing special about these action creators; they are the same ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"#async-actions"}),"Async Actions we mentioned before"),". However, because there are so many simple Parse API queries needed to initalise the app, we wanted to reduce boilerplate a bit. Inside our base Actions file, we created a base action creator:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/actions/parse.js */\nfunction loadParseQuery(type: string, query: Parse.Query): ThunkAction {\n  return (dispatch) => {\n    return query.find({\n      success: (list) => dispatch(({type, list}: any)),\n      error: logError,\n    });\n  };\n}\n")),Object(o.b)("p",null,"And then we re-use this multiple times very simply:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"  loadMaps: (): ThunkAction =>\n    loadParseQuery('LOADED_MAPS', new Parse.Query(Maps)),\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"loadMaps()")," becomes an action creator that'll run a simple Parse Query for all the stored Map data, and pass it along - when the query is complete - inside of the Action payload. ",Object(o.b)("inlineCode",{parentName:"p"},"loadMaps()")," and a load of other Parse data Actions can be found being dispatched in the ",Object(o.b)("inlineCode",{parentName:"p"},"componentDidMount()")," function of the entire app (",Object(o.b)("inlineCode",{parentName:"p"},"js/F8App.js"),"), which means the app fetches all Parse data which it is first loaded."),Object(o.b)("h5",{id:"parse-and-reducers"},"Parse and Reducers"),Object(o.b)("p",null,"We've cut down repetition in our Actions, but we want to reduce this boilerplate inside our Reducers too. These will receive a bunch of Parse API data from the Action payloads and have to map them to the ",Object(o.b)("inlineCode",{parentName:"p"},"state")," tree. We create a single base Reducer for Parse data:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/reducers/createParseReducer.js */\nfunction createParseReducer<T>(\n  type: string,\n  convert: Convert<T>\n): Reducer<T> {\n  return function(state: ?Array<T>, action: Action): Array<T> {\n    if (action.type === type) {\n      // Flow can't guarantee {type, list} is a valid action\n      return (action: any).list.map(convert);\n    }\n    return state || [];\n  };\n}\n")),Object(o.b)("p",null,"This is a really simple Reducer (with lots of Flow type annotations thrown in), but let's see how it works with the child Reducers based off of it:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"/* from js/reducers/faqs.js */\nconst createParseReducer = require('./createParseReducer');\n\nexport type FAQ = {\n  id: string;\n  question: string;\n  answer: string;\n};\n\nfunction fromParseObject(map: Object): FAQ {\n  return {\n    id: map.id,\n    question: map.get('question'),\n    answer: map.get('answer'),\n  };\n}\n\nmodule.exports = createParseReducer('LOADED_FAQS', fromParseObject);\n")),Object(o.b)("p",null,"So instead of repeating the ",Object(o.b)("inlineCode",{parentName:"p"},"createParseReducer")," portion of the code each time, we're simply passing an object to the base Reducer that maps the API data to the structure we want for our ",Object(o.b)("inlineCode",{parentName:"p"},"state")," tree."),Object(o.b)("p",null,"Now we have an app with a well-structured and easy to understand data flow, connection to our Parse server, and even offline syncing of our Store to local storage."))}p.isMDXComponent=!0}}]);